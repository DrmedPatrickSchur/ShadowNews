/**
 * @fileoverview User Database Model
 * 
 * Mongoose schema definition for user documents in the MongoDB database.
 * Defines the complete user data structure, validation rules, and database interactions
 * for the ShadowNews platform user system.
 * 
 * Key Features:
 * - User authentication with secure password hashing
 * - Unique ShadowNews email address generation (@shadownews.community)
 * - Comprehensive user profile fields (bio, avatar, preferences)
 * - Karma/reputation system integration
 * - Email verification and password reset token management
 * - Repository ownership and membership tracking
 * - Security features (account status, verification flags)
 * 
 * Schema Fields:
 * - username: Unique identifier, URL-safe format
 * - email: Primary contact email for authentication
 * - shadownewsEmail: Auto-generated @shadownews.community address
 * - password: Bcrypt-hashed password (excluded from queries by default)
 * - profile: Display name, bio, avatar, location
 * - karma: Reputation points from community interactions
 * - preferences: User settings and notification preferences
 * - verification: Email verification and account status
 * - repositories: Owned and member repositories
 * - tokens: Password reset and email verification tokens
 * 
 * Relationships:
 * - One-to-many with Posts (user creates posts)
 * - One-to-many with Comments (user creates comments)
 * - Many-to-many with Repositories (user owns/members)
 * - One-to-one with Karma tracking
 * 
 * Indexes:
 * - username: Unique index for fast user lookup
 * - email: Unique index for authentication
 * - shadownewsEmail: Sparse unique index for email routing
 * - karma.total: Index for reputation-based queries
 * 
 * Security Features:
 * - Password auto-hashing on save
 * - Email verification workflow
 * - Password reset token generation
 * - Account status tracking (active/suspended/deleted)
 * 
 * @author ShadowNews Team
 * @version 1.0.0
 * @since 2024-01-01
 * @lastModified 2025-01-27
 */

// Mongoose ODM for MongoDB schema definition and model creation
const mongoose = require('mongoose');

// Bcrypt library for secure password hashing
const bcrypt = require('bcryptjs');

// Node.js crypto module for token generation
const crypto = require('crypto');

/**
 * User Schema Definition
 * Comprehensive schema for user documents with validation, indexes, and middleware
 */
const userSchema = new mongoose.Schema({
  /**
   * Core Identity Fields
   * Essential fields for user identification and authentication
   */
  
  // Unique username for user identification and URL generation
  username: {
    type: String,
    required: [true, 'Username is required'],
    unique: true, // Enforces uniqueness at database level
    trim: true, // Remove leading/trailing whitespace
    lowercase: true, // Convert to lowercase for consistency
    minlength: [3, 'Username must be at least 3 characters'],
    maxlength: [30, 'Username cannot exceed 30 characters'],
    // URL-safe format: lowercase letters, numbers, underscores, hyphens only
    match: [/^[a-z0-9_-]+$/, 'Username can only contain lowercase letters, numbers, underscores, and hyphens']
  },
  
  // Primary email address for authentication and notifications
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true, // One account per email address
    lowercase: true, // Normalize email format
    trim: true, // Remove whitespace
    // Standard email validation regex
    match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Please provide a valid email']
  },
  
  // Auto-generated ShadowNews email address (username@shadownews.community)
  shadownewsEmail: {
    type: String,
    unique: true, // Each user gets unique ShadowNews email
    sparse: true, // Allow null values while maintaining uniqueness for non-null
    lowercase: true, // Consistent format
    immutable: true // Cannot be changed after creation
  },
  
  // Hashed password for authentication
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: [8, 'Password must be at least 8 characters'],
    select: false // Exclude from queries by default for security
  },
  
  /**
   * Profile Information Fields
   * Optional fields for user profile customization
   */
  
  // Display name shown to other users (can differ from username)
  displayName: {
    type: String,
    trim: true,
    maxlength: [50, 'Display name cannot exceed 50 characters']
  },
  
  // User biography/description for profile page
  bio: {
    type: String,
    maxlength: [500, 'Bio cannot exceed 500 characters']
  },
 
 avatar: {
   type: String,
   default: null
 },
 
 karma: {
   total: { type: Number, default: 0 },
   posts: { type: Number, default: 0 },
   comments: { type: Number, default: 0 },
   curation: { type: Number, default: 0 },
   repositories: { type: Number, default: 0 }
 },
 
 badges: [{
   type: {
     type: String,
     enum: ['early_adopter', 'curator', 'contributor', 'builder', 'ambassador', 'golden_curator']
   },
   awardedAt: { type: Date, default: Date.now },
   description: String
 }],
 
 preferences: {
   emailDigest: {
     enabled: { type: Boolean, default: true },
     frequency: { type: String, enum: ['daily', 'weekly', 'never'], default: 'daily' },
     timezone: { type: String, default: 'UTC' }
   },
   notifications: {
     comments: { type: Boolean, default: true },
     mentions: { type: Boolean, default: true },
     follows: { type: Boolean, default: true },
     repositoryUpdates: { type: Boolean, default: true }
   },
   privacy: {
     showEmail: { type: Boolean, default: false },
     showRepositories: { type: Boolean, default: true },
     allowInvites: { type: Boolean, default: true }
   },
   theme: { type: String, enum: ['light', 'dark', 'auto'], default: 'auto' }
 },
 
 following: [{
   type: mongoose.Schema.Types.ObjectId,
   ref: 'User'
 }],
 
 followers: [{
   type: mongoose.Schema.Types.ObjectId,
   ref: 'User'
 }],
 
 followedHashtags: [{
   type: String,
   lowercase: true,
   trim: true
 }],
 
 repositories: [{
   type: mongoose.Schema.Types.ObjectId,
   ref: 'Repository'
 }],
 
 savedPosts: [{
   type: mongoose.Schema.Types.ObjectId,
   ref: 'Post'
 }],
 
 votedPosts: [{
   post: { type: mongoose.Schema.Types.ObjectId, ref: 'Post' },
   vote: { type: Number, enum: [1, -1] },
   votedAt: { type: Date, default: Date.now }
 }],
 
 votedComments: [{
   comment: { type: mongoose.Schema.Types.ObjectId, ref: 'Comment' },
   vote: { type: Number, enum: [1, -1] },
   votedAt: { type: Date, default: Date.now }
 }],
 
 emailVerified: { type: Boolean, default: false },
 emailVerificationToken: String,
 emailVerificationExpires: Date,
 
 passwordResetToken: String,
 passwordResetExpires: Date,
 
 twoFactorSecret: {
   type: String,
   select: false
 },
 twoFactorEnabled: { type: Boolean, default: false },
 
 apiKeys: [{
   key: { type: String, select: false },
   name: String,
   permissions: [String],
   lastUsed: Date,
   createdAt: { type: Date, default: Date.now }
 }],
 
 loginHistory: [{
   ip: String,
   userAgent: String,
   timestamp: { type: Date, default: Date.now }
 }],
 
 flags: {
   isActive: { type: Boolean, default: true },
   isBanned: { type: Boolean, default: false },
   isVerified: { type: Boolean, default: false },
   isPremium: { type: Boolean, default: false },
   isAdmin: { type: Boolean, default: false },
   isModerator: { type: Boolean, default: false }
 },
 
 stats: {
   postsCount: { type: Number, default: 0 },
   commentsCount: { type: Number, default: 0 },
   repositoriesCount: { type: Number, default: 0 },
   followersCount: { type: Number, default: 0 },
   followingCount: { type: Number, default: 0 }
 },
 
 lastActiveAt: { type: Date, default: Date.now },
 lastPostAt: Date,
 lastCommentAt: Date,
 
 metadata: {
   referredBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
   signupSource: { type: String, enum: ['web', 'email', 'api', 'mobile'] },
   signupIp: String,
   userAgent: String
 }
}, {
 timestamps: true,
 toJSON: { virtuals: true },
 toObject: { virtuals: true }
});

// Indexes
userSchema.index({ email: 1 });
userSchema.index({ username: 1 });
userSchema.index({ shadownewsEmail: 1 });
userSchema.index({ karma: -1 });
userSchema.index({ createdAt: -1 });
userSchema.index({ 'flags.isActive': 1 });
userSchema.index({ followedHashtags: 1 });

// Virtual for profile URL
userSchema.virtual('profileUrl').get(function() {
 return `/u/${this.username}`;
});

// Virtual for karma level
userSchema.virtual('karmaLevel').get(function() {
 const totalKarma = this.karma.total;
 if (totalKarma >= 5000) return 'ambassador';
 if (totalKarma >= 1000) return 'poweruser';
 if (totalKarma >= 500) return 'contributor';
 if (totalKarma >= 100) return 'member';
 return 'newbie';
});

// Pre-save middleware
userSchema.pre('save', async function(next) {
 // Generate Shadownews email
 if (!this.shadownewsEmail && this.username) {
   this.shadownewsEmail = `${this.username}@shadownews.community`;
 }
 
 // Hash password
 if (this.isModified('password')) {
   const salt = await bcrypt.genSalt(10);
   this.password = await bcrypt.hash(this.password, salt);
 }
 
 // Set display name if not provided
 if (!this.displayName) {
   this.displayName = this.username;
 }
 
 next();
});

// Methods
userSchema.methods.comparePassword = async function(candidatePassword) {
 return await bcrypt.compare(candidatePassword, this.password);
};

userSchema.methods.generateEmailVerificationToken = function() {
 const verificationToken = crypto.randomBytes(32).toString('hex');
 this.emailVerificationToken = crypto
   .createHash('sha256')
   .update(verificationToken)
   .digest('hex');
 this.emailVerificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 hours
 return verificationToken;
};

userSchema.methods.generatePasswordResetToken = function() {
 const resetToken = crypto.randomBytes(32).toString('hex');
 this.passwordResetToken = crypto
   .createHash('sha256')
   .update(resetToken)
   .digest('hex');
 this.passwordResetExpires = Date.now() + 60 * 60 * 1000; // 1 hour
 return resetToken;
};

userSchema.methods.generateApiKey = function(name, permissions = ['read']) {
 const apiKey = crypto.randomBytes(32).toString('hex');
 const hashedKey = crypto
   .createHash('sha256')
   .update(apiKey)
   .digest('hex');
 
 this.apiKeys.push({
   key: hashedKey,
   name,
   permissions
 });
 
 return apiKey;
};

userSchema.methods.updateKarma = function(type, amount) {
 this.karma.total += amount;
 if (this.karma[type] !== undefined) {
   this.karma[type] += amount;
 }
 
 // Check for badge awards
 if (this.karma.total >= 100 && !this.badges.some(b => b.type === 'member')) {
   this.badges.push({ type: 'member', description: 'Reached 100 karma' });
 }
 if (this.karma.total >= 500 && !this.badges.some(b => b.type === 'contributor')) {
   this.badges.push({ type: 'contributor', description: 'Reached 500 karma' });
 }
 if (this.karma.total >= 1000 && !this.badges.some(b => b.type === 'poweruser')) {
   this.badges.push({ type: 'poweruser', description: 'Reached 1000 karma' });
 }
 if (this.karma.total >= 5000 && !this.badges.some(b => b.type === 'ambassador')) {
   this.badges.push({ type: 'ambassador', description: 'Reached 5000 karma' });
 }
};

userSchema.methods.canCreateRepository = function() {
 return this.karma.total >= 500 || this.flags.isPremium || this.flags.isAdmin;
};

userSchema.methods.getPublicProfile = function() {
 const obj = this.toObject();
 delete obj.password;
 delete obj.emailVerificationToken;
 delete obj.passwordResetToken;
 delete obj.twoFactorSecret;
 delete obj.apiKeys;
 delete obj.loginHistory;
 if (!obj.preferences.privacy.showEmail) {
   delete obj.email;
 }
 return obj;
};

const User = mongoose.model('User', userSchema);

module.exports = User;